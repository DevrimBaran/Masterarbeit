\chapter{Choosing the Optimal Wait-Free Data Structure and algorithm}\label{ch:choosing-the-optimal-wait-free-data-structure}

\section{Optimal Wait-Free Data Structure}\label{sec:optimal-wait-free-data-structure}

An important question is what data structure to use for the implementation of a wait-free synchronisation technique for \ac{IPC}. M. Herlihy showed that every data structure can be made wait-free \cite{herlihy1991wait}. So it is important to choose the optimal data structure for our use. Considering that the reason of this work is to optimize modern manufacturing and automation, some form of correct data flow order is as well necessary for correct work flow for instance in an modern manufacturing line or more critical in a driverless car. From that point on we can think of an already natural fit like \ac{FIFO} queues. Natural because in such queues a producer process can enqueue messages and the consumer process can dequeue messages sequentially. This models real-world data flows (sensor readings, commands, network packets), which are inherently sequential. Consequently with such queues the order of the data flow is preversed without the need of implementing additional functionalities. In contrast, data structures like stacks, sets, or maps do not maintain this kind of arrival order and moreover add semantics like \ac{LIFO} order or key-value pairs, which are in most cases not desired or even unnecessary. This would bring in the need of additional functions to just get rid of undesired side effects. Furthermore in a queue we only have two operations, an enqueue and an dequeue operation. All the other data structures introduce more operations and therefore more complexity. The less operations we have, the less complex the implementation will be. Because of these advantages and also because of the fact that in most publications in the wait-free domain queues are beeing used, limiting this thesis to queues only is plausible. \cite{jiffy}

\section{Wait-Free Algorithms}\label{sec:wait-free-alg}
As we know now on which data structure we should focus an important question is which algorithms to use. There are different cases where different kind of algorithms make more sense. We will decide this contention dependant.

\subsection{Single Producer and Single Consumer}\label{sec:single-producer-and-single-consumer}
This is the most simple form of \ac{IPC}. In \ac{SPSC} there is no contention from other processes, because we only have one producer and one consumer. The producer can enqueue processes without any other process interfering. The same goes for the consumer. The simplest and most widely used wait-free queue was described by Leslie Lamport in 1983. In his designe a fixed-size buffer as an array is preallocated. The producer and the consumer each advance a index, wich is the write index and read index, modulo the buffer size: 

\subsection{Multiple Producer and Single Consumer}\label{sec:multiple-producer-and-single-consumer}

\subsection{Single Producer and Multiple Consumer}\label{sec:single-producer-and-multiple-consumer}

\subsection{Multiple Producer and Multiple Consumer}\label{sec:multiple-producer-and-multiple-consumer}