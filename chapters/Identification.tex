\chapter{Choosing the Optimal Wait-Free Data Structure and algorithm}\label{ch:choosing-the-optimal-wait-free-data-structure}

\section{Optimal Wait-Free Data Structure}\label{sec:optimal-wait-free-data-structure}

An important question is what data structure to use for the implementation of a wait-free synchronisation technique for \ac{IPC}. M. Herlihy showed that every data structure can be made wait-free \cite{herlihy1991wait}. So it is important to choose the optimal data structure for our use. Considering that the reason of this work is to optimize modern manufacturing and automation, some form of correct data flow order is as well necessary for correct work flow for instance in an modern manufacturing line or more critical in a driverless car. From that point on we can think of an already natural fit like \ac{FIFO} queues. Natural because in such queues a producer process can enqueue messages and the consumer process can dequeue messages sequentially. This models real-world data flows (sensor readings, commands, network packets), which are inherently sequential. Consequently with such queues the order of the data flow is preversed without the need of implementing additional functionalities. In contrast, data structures like stacks, sets, or maps do not maintain this kind of arrival order and moreover add semantics like \ac{LIFO} order or key-value pairs, which are in most cases not desired or even unnecessary. This would bring in the need of additional functions to just get rid of undesired side effects. Furthermore in a queue we only have two operations, an enqueue and an dequeue operation. All the other data structures introduce more operations and therefore more complexity. The less operations we have, the less complex the implementation will be. Because of these advantages and also because of the fact that in most publications in the wait-free domain queues are beeing used, limiting this thesis to queues only is plausible. \cite{jiffy}

\section{Wait-Free Algorithms}\label{sec:wait-free-alg}
As we know now on which data structure we should focus an important question is which algorithms to use. There are different cases where different kind of algorithms make more sense. We will decide this contention dependant. There exist algorithms for \ac{SPSC}, \ac{MPSC}, \ac{SPMC} and \ac{MPMC} queues. Since all of them have different complexity in runtime and space, it is important to choose the right one for the right use case to save resources and have faster execution times to meet the timing constraints of \ac{HRTS}. In modern manufacturing and automation devices are used which can run multiple applications on the single device. This could mean that every application running on that device could be a producer and a consumer to each other and also maybe some single application of all applications running on that device produces data for just a single other consuming application. And maybe some single application is a producer for multiple consuming applications and multiple applications are producers of a single consuming application. So it can be that all cases can occur in just one design. This means that we have to consider all the different cases of contention. In the following sections we will discuss the different cases and their algorithms. We will also implement them and test them performance wise before we will implement a final solution which uses all the algorithms automatically for the right use of contention between applications. And even if only one pattern occurs for different devices it makes sense to implement all of them, so that in an automated system with multiple device only one implementated solution is needed to be installed.

\subsection{Single Producer and Single Consumer}\label{subsec:single-producer-and-single-consumer}
This is the most simple form of \ac{IPC}. In \ac{SPSC} there is no contention from other processes, because we only have one producer and one consumer. The producer can enqueue processes without any other process interfering. The same goes for the consumer. Here only lockfreedom between writer and reader process is sufficient to achieve wait-freedom.

\subsection{Multiple Producer and Single Consumer}\label{subsec:multiple-producer-and-single-consumer}

\subsection{Single Producer and Multiple Consumer}\label{subsec:single-producer-and-multiple-consumer}

\subsection{Multiple Producer and Multiple Consumer}\label{subsec:multiple-producer-and-multiple-consumer}