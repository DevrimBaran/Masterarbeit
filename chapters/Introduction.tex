\chapter{Introduction}\label{ch:introduction}

\section{Motivation}\label{sec:motivation}

In modern manufacturing and automation, control systems must operate under strict timing constraints to function reliably. If a system fails to meet these constraints, unexpected delays can disrupt processes, leading to instability or even hazardous failures in safety-critical environments. For this reason, \ac{RTOS} and low-level programming languages like C, C++, and Rust are widely used to ensure predictable execution times.

Many real-time applications involve multiple tasks that must run concurrently and share resources efficiently. Without proper synchronization, problems such as data corruption or race conditions can occur leading to unpredictable behavior. Traditional synchronization methods are commonly used to manage access to shared resources and rely on blocking processes to share data through shared memorys. However, these blocking mechanisms introduce significant challenges in real-time settings. Since Traditional synchronization methods require processes to wait for resource availability, they can lead to increased response times, potential deadlocks, potential process starvations, and potential priority inversions. These delays are unacceptable in systems that require strict timing guarantees. \cite{herlihy1991wait, brandenburg2019multiprocessorrealtimelockingprotocols, kode2024analysisSynchronization}

Consider, for instance, a factory setting where a worker presses an emergency stop button to halt machinery. The system must react instantly, as any delay could lead to severe consequences, including equipment damage or injury. However, if the system experiences one of the discussed problems, it may become unresponsive at a critical moment. This highlights a fundamental issue with blocking synchronization techniques: while they ensure orderly access to shared resources, they can also introduce delays that are unacceptable in real-time environments.

To overcome these limitations, there is an increasing interest in wait-free and lock-free synchronization techniques. A wait-free algorithm guarantees that every operation completes in a finite number of steps, regardless of contention from other processes. This property ensures system responsiveness and predictability, which are essential for real-time applications. By eliminating blocking and contention-based delays, wait-free synchronization prevents priority inversion and ensures that high-priority tasks execute without interference. \cite{kogan2012methodology, herlihy1991wait, brandenburg2019multiprocessorrealtimelockingprotocols}

Lock-free synchronization, on the other hand, ensures that at least one process makes progress in a finite number of steps, but it does not guarantee that every process will complete its operation. While lock-free algorithms tend to be more efficient than wait-free ones, they allow the possibility of process starvation in high-contention scenarios. This can be problematic in real-time and heterogeneous computing environments, where some processes might be repeatedly delayed due to interference from faster processes. So we see that lock-free synchronization has a slightly different goal then wait-free synchronization, which is why in this work we will only focus on wait-free datastructures to stay in the scope of this work. \cite{kogan2012methodology}

Efficient synchronization mechanisms are particularly important in the context of \ac{IPC}, which plays a crucial role in \ac{RTS}. \ac{IPC} allows processes to exchange data efficiently, but its performance is heavily influenced by the synchronization techniques used. Traditional \ac{IPC} mechanisms, which often rely on blocking some processes, can introduce significant latency and reduce throughput. Wait-free data structures offer a promising alternative by ensuring that communication operations complete within predictable time bounds. However, selecting appropriate wait-free data structures and evaluating their performance in real-time environments remains a challenge. \cite{timnat2014practical, michael1996simple, huang2002improvingWaitFree, pellegrini2020relevancewaitfreecoordinationalgorithms}

The Rust programming language provides useful features for implementing real-time synchronization mechanisms. Its ownership model and strict type system prevent data races and enforce safe concurrency without requiring traditional locking mechanisms. Additionally, Rust offers fine-grained control over system resources, making it a strong candidate for real-time applications that demand both low latency and high reliability. \cite{xu2023rust, sharma2024rustembeddedsystemscurrent}

The concepts and methods introduced here, including \ac{RTS}, \ac{IPC}, synchronization techniques and problems, wait-free synchronization, and the rust programming language are explored in greater depth in \cref{ch:background}. 

\section{Objective}\label{sec:objective}

The primary goal of this research is to find a wait-free data structure that can be used to implement a wait-free synchronization for \ac{IPC} though shared memory in \ac{RTS} using Rust. To do so, this study aims to:

\begin{itemize}
\item Identify and analyze existing wait-free synchronization techniques for \ac{IPC} through shared memory for \ac{RTS}.
\item Implement and compare the performance of existing wait-free synchronization mechanisms for \ac{IPC} through a shared memory for real-time scenarios with each other.
\item Choose and analyze which wait-free data structure for \ac{IPC} through shared memory in a real-time setting using Rust that is best suited.
\end{itemize}

By addressing these objectives, this work contributes to the field of wait-free synchronization for \ac{IPC} in \ac{RTS} by providing a practical solution with rust. The insights gained from this research can help improve the reliability and performance of real-time applications across various domains.

\section{Structure of the Thesis}\label{sec:structure-of-the-thesis}


