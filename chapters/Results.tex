\chapter{Benchmarking and Results}\label{ch:results}
To finish the objective of this thesis at last a setting needs to be build were these algorithms are used for \ac{IPC} over shared memory. This setting was also used to benchmark the performance of these algorithms to Identify the best performing wait-free algorithms that can be used. In the \cite{githubMA} the folder benches includes the setting and benchmark of these algorithms. As seen as before these algorithms were divided into 4 categories, \ac{MPMC}, \ac{MPSC}, \ac{SPMC} and \ac{SPSC}. Therefore 4 different \ac{IPC} over shared memory settings were build to analyze firstly if all algorithms work as intended and secondly to compare the performance of all algorithms. Eventhough \ac{SPMC} category only has one algorithm, the build setting was still interesting to check and validate if the algorithm works as intended. After identifying the best algorithm 3 more settings were build. One setting was to see if the \ac{SPMC} queue or the best performing queues of the other categories would be faster for the \ac{SPSC} category. The same was done for the \ac{MPSC} category by checking if the best \ac{MPMC} queue or the best \ac{MPSC} queue would perform better. Finally for the \ac{SPMC} category the same was done to check if the best \ac{MPMC} or  \ac{SPMC} queue would be better. The best \ac{SPSC} queue could not be testet for higher producer or consumer numbers, since the missing helping structures and missing atomic primitives would lead to deadloccks or inconsistent data. The benchmarks were done on a system with an Intel i7-12700H x86 processer with 14 cores. The benchmarks were implemented with the help of the \texttt{criterion} crate, which is a benchmarking library for Rust. This chapter will show in general how the benchmarks settings were impplemented to understand the results later.

\section{Benchmark Structure}
All benchmarks were build in the same way, so that the results can be compared with each other. 